@startuml architecture-overview

title flul-test — Architecture Overview

skinparam linetype ortho
skinparam packageStyle rectangle

package "flul::test" {

    class "Suite<Derived>" as Suite <<CRTP>> {
        + {static} Register(Registry&) : void
        + SetUp() : void
        + TearDown() : void
    }

    class "Test<Derived>" as TestBuilder <<builder>> {
        + ExpectFail() : Test<Derived>&
        + Skip() : Test<Derived>&
        + Timeout(duration) : Test<Derived>&
    }

    class Registry {
        + Add(metadata, callable) : void
        + Tests() : span<TestEntry>
        + Filter(pattern) : void
        + FilterByTag(tag) : void
        + ExcludeByTag(tag) : void
        + List() : void
        + ListVerbose() : void
        + Shuffle(seed) : void
    }

    class Runner {
        + Runner(Registry&)
        + RunAll() : int
    }

    note as N_tmo
        After test completes, compare
        elapsed time to metadata.timeout.
        If exceeded → override outcome
        to Timeout. Just log.
    end note
    Runner .. N_tmo

    class "Expect<T>" as Expect {
        + Expect(actual, loc = source_location::current())
        + ToEqual(expected) : Expect&
        + ToBeTrue() : Expect&
        + ToBeFalse() : Expect&
        + ToBeGreaterThan(bound) : Expect&
        + ToBeLessThan(bound) : Expect&
        + ToNotEqual(unexpected) : Expect&
        + ToBeNear(expected, margin) : Expect&
        - loc_ : source_location
    }

    class "ExpectCallable<F>" as ExpectCallable {
        + ExpectCallable(callable, loc = source_location::current())
        + ToThrow<E>() : void
        + ToNotThrow() : void
        - loc_ : source_location
    }

    class AssertionError <<exception>> {
        + what() : string
        + actual : string
        + expected : string
        + location : source_location
    }

    enum Outcome {
        Pass
        Fail
        XFail
        XPass
        Skip
        Timeout
    }

    struct TestMetadata {
        + suite_name : string_view
        + test_name : string_view
        + tags : vector<string_view>
        + xfail : bool
        + skip : bool
        + timeout : optional<chrono::milliseconds>
    }

    struct TestEntry {
        + metadata : TestMetadata
        + callable : function<void()>
    }

    struct TestResult {
        + metadata : reference_wrapper<const TestMetadata>
        + outcome : Outcome
        + duration : chrono::nanoseconds
        + error : optional<AssertionError>
    }

    class Run <<free function>> {
        + Run(argc, argv, Registry&) : int
    }

    note as N_cli
        CLI flags:
        --list, --list-verbose
        --filter <pattern>
        --tag <tag>, --exclude-tag <tag>
        --randomize, --seed <N>
        --help
    end note
    Run .. N_cli
}

package "User Test Code" as user <<external>> {
    class "MySuite" as MySuite {
        + {static} Register(Registry&) : void
        + TestFoo() : void
        + TestBar() : void
    }
}

package "main()" as main <<external>> {
    note as N_main
        1. Create Registry
        2. Register suites
        3. return Run(argc, argv, registry)
    end note
}

MySuite -up-|> Suite : <<derives>>
Suite ..> Registry : registers into
Suite ..> TestBuilder : produces
TestBuilder ..> Registry : configures entry in
Run --> Runner : creates and runs
Run --> Registry : passes to Runner
Runner --> Registry : reads tests from
Runner ..> TestResult : produces
TestResult --> Outcome : classifies by
Expect ..> AssertionError : throws on failure
ExpectCallable ..> AssertionError : throws on failure
Runner ..> AssertionError : catches per test
Registry --> TestEntry : stores
TestEntry *-- TestMetadata : contains
TestResult ..> TestMetadata : references

@enduml
